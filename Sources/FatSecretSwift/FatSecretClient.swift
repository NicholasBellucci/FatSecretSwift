import Foundation
import CryptoSwift

/**
 The HTTP error

 - invalidKey: Key provided does not exist or is invalid
 - invalidSignature: The signature generated does not match
 */

private enum HTTPError: LocalizedError {
    case invalidKey
    case invalidSignature
    case unknown

    public var errorDescription: String? {
        switch self {
        case .invalidKey:
            return NSLocalizedString("Error: Invalid key", comment: "error")
        case .invalidSignature:
            return NSLocalizedString("Error: Invalid signature", comment: "error")
        default:
            return NSLocalizedString("Error: Unknown", comment: "error")
        }
    }
}


private enum maxSearchResults {
    static let foods    = 50
    static let recipes  = 50
}

/** HTTP Method: POST
 - URL: http://platform.fatsecret.com/rest/server.api
 */

/** List of all required request parameters

 - Parameter format: The return format type(JSON)
 - Parameter oauth_consumer_key: Users personal consumer key
 - Parameter oauth_signature_method: HMAC-SHA1
 - Parameter oauth_timestamp: Generated timestamp
 - Parameter oauth_nonce: Generate nonce
 - Parameter oauth_version: 1.0
 - Parameter oauth_signature: OAuth signature generated by encryption
 */

open class FatSecretClient {
    private var timestamp: String {
        get { return String(Int(Date().timeIntervalSince1970)) }
    }

    private var nonce: String {
        get {
            var string: String = ""
            let letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
            let char = Array(letters)

            for _ in 1...7 { string.append(char[Int(arc4random()) % char.count]) }

            return string
        }
    }

    /** Search
     - Description: Search for a food by name
     */
    public func searchFood(name: String, certPinningDelegate: CertificatePinningURLSessionDelegate? = nil, completion: @escaping (_ foods: Search) -> ()) {
        FatSecretParams.fatSecret = ["format":"json", "method":"foods.search", "search_expression":name] as Dictionary

        let components = generateSignature()
        fatSecretRequest(with: components, certPinningDelegate: certPinningDelegate) { data in
            guard let data = data else { return }
            let model = self.retrieve(data: data, type: [String: Search].self)
            let search = model!["foods"]
            completion(search!)
        }
    }

    /** Food
     - Description: Get a food item by id
     */
    public func getFood(id: String, certPinningDelegate: CertificatePinningURLSessionDelegate? = nil, completion: @escaping (_ foods: Food) -> ()) {
        FatSecretParams.fatSecret = ["format":"json", "method":"food.get", "food_id":id] as Dictionary

        let components = generateSignature()
        fatSecretRequest(with: components, certPinningDelegate: certPinningDelegate) { data in
            guard let data = data else { return }
            let model = self.retrieve(data: data, type: [String:Food].self)
            let food = model!["food"]
            completion(food!)
        }
    }
    
    
    /** Recipe Search
     - Description: Search for a recipe by name
     */
    public func searchRecipe(name: String, maxResults: Int = 20, certPinningDelegate: CertificatePinningURLSessionDelegate? = nil, completion: @escaping (Result<FSPRecipes, FBError>) -> Void) {
        let max = (0...50).contains(maxResults) ? maxResults : 20   // maxResults cannot be more than 50. Default value is 20.
        FatSecretParams.fatSecret = ["format":"json", "method":"recipes.search.v3", "must_have_images":"true", "search_expression":name, "max_results": String(max)] as Dictionary

        let components = generateSignature()
        fatSecretRecipeSearchRequest(with: components, certPinningDelegate: certPinningDelegate) { result in
            switch result {
            case .success(let recipes):
//                print("Successfully found recipes over internet.")
                completion(.success(recipes))

            case .failure(let error):
                print("Unable to load searched recipes from internet", error.localizedDescription)
                completion(.failure(.unableToGetRecipes))
            }
        }
    }

    /** Recipe
     - Description: Get a recipe item by id
     */
    public func getRecipe(id: String, certPinningDelegate: CertificatePinningURLSessionDelegate? = nil, completion: @escaping (Result<FSPSingleRecipe, FBError>) -> Void) {
        FatSecretParams.fatSecret = ["format":"json", "method":"recipe.get", "recipe_id":id] as Dictionary

        let components = generateSignature()
        fatSecretRecipeIDRequest(with: components, certPinningDelegate: certPinningDelegate) { result in
            switch result {
            case .success(let recipe):
//                print("Successfully found recipe id over internet.")
                completion(.success(recipe))

            case .failure(let error):
                print("Unable to load searched for recipe id from internet", error.localizedDescription)
                completion(.failure(.unableToGetRecipes))
            }
        }
    }
    
    
    

    public init() {}
}

extension FatSecretClient {
    fileprivate func fatSecretRequest(with components: URLComponents, certPinningDelegate: CertificatePinningURLSessionDelegate? = nil, completion: @escaping (_ data: Data?)-> ()) {
        var request = URLRequest(url: URL(string: String(describing: components).replacingOccurrences(of: "+", with: "%2B"))!)
        request.httpMethod = FatSecretParams.httpType
        
        let session = URLSession(configuration: URLSessionConfiguration.ephemeral, delegate: certPinningDelegate, delegateQueue: nil)

        let task = session.dataTask(with: request) { (data, response, error) in
            if let data = data {
                do {
                    let model = self.retrieve(data: data, type: [String:FSError].self)
                    if model != nil {
                        let error = model!["error"]
                        try self.checkForError(with: error!.code)
                    }

                    completion(data)
                } catch let error as NSError {
                    print(error.localizedDescription)
                }
            } else if let error = error {
                print(error.localizedDescription)
            }
        }
        task.resume()
    }

    fileprivate func retrieve<T: Decodable>(data: Data, type: T.Type) -> T? {
        let decoder = JSONDecoder()
        do {
            let model = try decoder.decode(type, from: data)
            return model
        } catch {
            return nil
        }
    }

    
    func fatSecretRecipeSearchRequest(with components: URLComponents, certPinningDelegate: CertificatePinningURLSessionDelegate? = nil, completed: @escaping (Result<FSPRecipes, FBError>) -> Void) {
        var request = URLRequest(url: URL(string: String(describing: components).replacingOccurrences(of: "+", with: "%2B"))!)
        request.httpMethod = FatSecretParams.httpType

        let session = URLSession(configuration: URLSessionConfiguration.ephemeral, delegate: certPinningDelegate, delegateQueue: nil)
        
        let task = session.dataTask(with: request) { (data, response, error) in
            if let _ = error {
                completed(.failure(.unableToComplete))
                return
            }
            
            // error code '200' = OK, i.e., no error.
            guard let response = response as? HTTPURLResponse, response.statusCode == 200 else {
                completed(.failure(.invalidResponse))
                return
            }
            
            guard let data = data else {
                completed(.failure(.invalidData))
                return
            }
            
            // After 'guard' error checks, no get/decode the data
            do {
                let decoder = JSONDecoder()
                let recipes = try decoder.decode(FSPRecipeSearch.self, from: data)
                completed(.success(recipes.recipes)) // escaping value 'recipes.recipes' is of type 'FSPRecipes'
            } catch {
                print("Unable to retreive recipes, error: ", error.localizedDescription)
                completed(.failure(.invalidData))
            }
        }
        task.resume()
    }
    
    
    func fatSecretRecipeIDRequest(with components: URLComponents, certPinningDelegate: CertificatePinningURLSessionDelegate? = nil, completed: @escaping (Result<FSPSingleRecipe, FBError>) -> Void) {
        var request = URLRequest(url: URL(string: String(describing: components).replacingOccurrences(of: "+", with: "%2B"))!)
        request.httpMethod = FatSecretParams.httpType

        let session = URLSession(configuration: URLSessionConfiguration.ephemeral, delegate: certPinningDelegate, delegateQueue: nil)
        
        let task = session.dataTask(with: request) { (data, response, error) in
            if let _ = error {
                completed(.failure(.unableToComplete))
                return
            }
            
            // error code '200' = OK, i.e., no error.
            guard let response = response as? HTTPURLResponse, response.statusCode == 200 else {
                completed(.failure(.invalidResponse))
                return
            }
            
            guard let data = data else {
                completed(.failure(.invalidData))
                return
            }
            
            // After 'guard' error checks, no get/decode the data
            do {
                let decoder = JSONDecoder()
                let recipeID = try decoder.decode(FSPRecipeIDSearch.self, from: data)
                completed(.success(recipeID.recipe)) // escaping value 'recipeID.recipe' is of type 'FSPSingleRecipe'
            } catch {
                print("Unable to retreive recipes, error: ", error.localizedDescription)
                completed(.failure(.invalidData))
            }
        }
        task.resume()
    }
    
    
    
    fileprivate func generateSignature() -> URLComponents {
        FatSecretParams.oAuth.updateValue(self.timestamp, forKey: "oauth_timestamp")
        FatSecretParams.oAuth.updateValue(self.nonce, forKey: "oauth_nonce")

        var oauthComponents = URLComponents(string: FatSecretParams.url)!
        oauthComponents.componentsForOAuthSignature(from: Array<String>().parameters)

        let parameters = oauthComponents.getURLParameters()
        let encodedURL = FatSecretParams.url.addingPercentEncoding(withAllowedCharacters: CharacterSet().percentEncoded)!
        let encodedParameters = parameters.addingPercentEncoding(withAllowedCharacters: CharacterSet().percentEncoded)!
        let signatureBaseString = "\(FatSecretParams.httpType)&\(encodedURL)&\(encodedParameters)"
        let signature = String().getSignature(key: FatSecretParams.key, params: signatureBaseString)

        var urlComponents = URLComponents(string: FatSecretParams.url)!
        urlComponents.componentsForURL(from: Array<String>().parameters)
        urlComponents.queryItems?.append(URLQueryItem(name: "oauth_signature", value: signature))
        return urlComponents
    }

    fileprivate func checkForError(with code: Int) throws {
        switch code {
        case 5:
            throw HTTPError.invalidKey
        case 8:
            throw HTTPError.invalidSignature
        default:
            throw HTTPError.unknown
        }
    }
}
